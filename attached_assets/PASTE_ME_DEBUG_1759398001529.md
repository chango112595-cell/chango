# PASTE_ME_DEBUG.md — Project‑wide Debug Monitor + Safe Auto‑Heal (Isolated)

Adds:
- **Debug Bus** (central event logging)
- **Overlay Monitor** (live events + health)
- **Health Watchdog** (STT/TTS/gate/bootstrap checks)
- **Safe Auto‑Heal** (restart STT, cancel stuck TTS, re‑init modules)
- Feature‑flagged, fully **isolated**. No code edits at runtime beyond restarts.

---

## 0) Feature flags
**File:** `src/config/featureFlags.ts` (add keys if missing)
```ts
export const Features = {
  HandsFreeUI: false,
  WakeWord: true,
  AlwaysListening: true,
  AnswerOnlyWhenAsked: true,
  AnswerOnlyWhenAddressed: true,
  CompactHeader: true,
  GuardedCancel: true,

  DebugOverlay: true,      // show live overlay in non‑prod
  DebugBus: true,          // route events to central logger
  AutoHeal: true,          // enable safe restarts/rebinds
} as const;
export type FeatureKey = keyof typeof Features;
export const isOn = (k: FeatureKey) => !!Features[k];
```

---

## 1) Debug Bus (central logging)
**File:** `src/dev/debugBus.ts`
```ts
type Level = "info"|"warn"|"error";
export type DebugEvent = {
  t: number;                    // timestamp
  src: string;                  // source module name
  type: string;                 // event kind
  msg?: string;
  data?: any;
  lvl?: Level;
};

class DebugBus {
  private subs = new Set<(e:DebugEvent)=>void>();
  private history: DebugEvent[] = [];
  private max = 400;

  on(fn:(e:DebugEvent)=>void){ this.subs.add(fn); return ()=>this.subs.delete(fn); }
  emit(e: Omit<DebugEvent,"t">){ 
    const ev = { t: Date.now(), lvl:"info" as Level, ...e };
    this.history.unshift(ev);
    if (this.history.length>this.max) this.history.pop();
    for(const f of this.subs) try{ f(ev) }catch{}
    try{ (window as any).__CH_DEBUG__ = this; }catch{}
  }
  getHistory(){ return [...this.history]; }
}

export const debugBus = new DebugBus();

export const dbg = {
  info(src:string, type:string, msg?:string, data?:any){ debugBus.emit({src,type,msg,data,lvl:"info"}); },
  warn(src:string, type:string, msg?:string, data?:any){ debugBus.emit({src,type,msg,data,lvl:"warn"}); },
  error(src:string, type:string, msg?:string, data?:any){ debugBus.emit({src,type,msg,data,lvl:"error"}); },
};
```

---

## 2) Hook key subsystems to Debug Bus
Patch minimal logs in your existing modules. Examples:

**File:** `src/voice/always_listen.ts` (add imports + logs)
```ts
import { dbg } from "../dev/debugBus";
// inside startAlwaysListening():
dbg.info("STT","init");
rec!.onresult = (e:any)=>{
  const res = e?.results?.[e.resultIndex];
  const text = res && res[0]?.transcript ? String(res[0].transcript).trim() : "";
  if (text){
    dbg.info("STT","heard", text.slice(0,120));
    voiceBus.emitUserSpeech(text);
  }
};
rec!.onend   = ()=> dbg.warn("STT","end","restart");
rec!.onerror = (err:any)=> dbg.error("STT","error", String(err));
```

**File:** `src/modules/conversationEngine/index.ts` (add imports + logs)
```ts
import { dbg } from "../../dev/debugBus";
// when gate passes:
dbg.info("NLP","gate.pass", g.reason, g.text);
// before speak:
dbg.info("TTS","speak", reply.slice(0,120));
// on catch:
dbg.error("TTS","error", (e as any)?.message || "tts");
```

**File:** `src/voice/voiceBus.ts` (emit notable state)
```ts
import { dbg } from "../dev/debugBus";
// in setMute / setPower:
dbg.warn("VOICE","mute", String(v));
dbg.warn("VOICE","power", String(v));
// in cancelSpeak:
dbg.info("VOICE","cancel", source);
```

---

## 3) Overlay Monitor (live log + health)
**File:** `src/dev/DebugOverlay.tsx`
```tsx
import React from "react";
import { debugBus, DebugEvent } from "./debugBus";
import { isOn } from "../config/featureFlags";

function StatusDot({ok}:{ok:boolean}){
  return <span style={{display:"inline-block",width:8,height:8,borderRadius:99,
    background: ok? "#3cff9e" : "#ff5151", boxShadow: ok? "0 0 10px #3cff9eaa":"0 0 10px #ff5151aa"}}/>;
}

export default function DebugOverlay(){
  const [lines,setLines]=React.useState<DebugEvent[]>([]);
  const [health,setHealth]=React.useState({stt:false, tts:true, gate:false, boot:true});
  React.useEffect(()=>{
    if (!isOn("DebugOverlay")) return;
    const off = debugBus.on((e)=>{
      if (e.src==="STT" && e.type==="heard") setHealth(h=>({...h, stt:true, gate:h.gate }));
      if (e.src==="NLP" && e.type==="gate.pass") setHealth(h=>({...h, gate:true}));
      if (e.src==="TTS" && e.type==="speak") setHealth(h=>({...h, tts:true}));
      setLines(x=>[e, ...x].slice(0,14));
    });
    return off;
  },[]);

  if (!isOn("DebugOverlay")) return null;
  return (
    <div style={{position:"fixed",bottom:10,left:10,zIndex:9999,
      background:"rgba(0,0,0,.6)", border:"1px solid #0ff", color:"#0ff",
      padding:"10px 12px", borderRadius:10, fontFamily:"ui-monospace, SFMono-Regular, Menlo, monospace", fontSize:12}}>
      <div style={{display:"flex", gap:10, marginBottom:6}}>
        <div>STT <StatusDot ok={health.stt}/></div>
        <div>Gate <StatusDot ok={health.gate}/></div>
        <div>TTS <StatusDot ok={health.tts}/></div>
      </div>
      {lines.map((e,i)=>(
        <div key={i}>{new Date(e.t).toLocaleTimeString()} — {e.src}:{e.type}{e.msg?(" · "+e.msg):""}</div>
      ))}
    </div>
  );
}
```

Mount (temporary) in your root:
```tsx
{process.env.NODE_ENV !== "production" && <DebugOverlay/>}
```

---

## 4) Health Watchdog + Safe Auto‑Heal
**File:** `src/dev/health/monitor.ts`
```ts
import { dbg } from "../debugBus";
import { voiceBus } from "../../voice/voiceBus";
import { isOn } from "../../config/featureFlags";
import { initTTS } from "../../app/initTTS";
import { startAlwaysListening } from "../../voice/always_listen";

type Heart = { lastSTT: number; lastGate: number; lastTTSSpeak: number };
const heart: Heart = { lastSTT: 0, lastGate: 0, lastTTSSpeak: 0 };

export function beat(kind: "stt"|"gate"|"tts"){
  const now = Date.now();
  if (kind==="stt") heart.lastSTT = now;
  if (kind==="gate") heart.lastGate = now;
  if (kind==="tts") heart.lastTTSSpeak = now;
}

const STT_TIMEOUT = 12000;
const TTS_STUCK   = 10000;

let armed = false;
export function startHealthWatch(){
  if (armed) return; armed = true;
  dbg.info("HEALTH","start");

  setInterval(async ()=>{
    if (!isOn("AutoHeal")) return;
    const now = Date.now();

    if (now - heart.lastSTT > STT_TIMEOUT){
      dbg.warn("HEALTH","stt.restart");
      try {
        voiceBus.cancelSpeak("system");
        await new Promise(r=>setTimeout(r,150));
        startAlwaysListening();
      } catch(e){ dbg.error("HEALTH","stt.restart.error", String(e)); }
    }

    const speaking = typeof window!=="undefined" && window.speechSynthesis?.speaking;
    if (speaking && now - heart.lastTTSSpeak > TTS_STUCK){
      dbg.warn("HEALTH","tts.cancel.stuck");
      try { window.speechSynthesis.cancel(); } catch {}
    }

    if (voiceBus.mute)  dbg.warn("HEALTH","muted");
    if (!voiceBus.power) dbg.warn("HEALTH","power.off");

    try { initTTS(); } catch {}
  }, 3000);
}
```

**Wire beats (optional but useful):**
```ts
// STT onresult -> beat("stt")
// gate.pass    -> beat("gate")
// before speak -> beat("tts")
```

---

## 5) Start in bootstrap
**File:** `src/app/bootstrap.ts`
```ts
import { startHealthWatch } from "../dev/health/monitor";

export function bootstrapChango(){
  initTTS();
  initConversationEngine();
  startAlwaysListening();
  startHealthWatch(); // start watchdog
}
```

**Done.** Overlay + auto‑heal are active (dev only by default). Disable via flags when you’re satisfied.
