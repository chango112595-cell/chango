Got it. Here’s a single drop-in PASTE_ME.md that restores your UI (no changes to your components/layout) and adds only the voice fixes. It uses isolated *_safe modules so nothing collides with your code. Copy this file into your repo and follow the two wiring lines at the end.

⸻

PASTE_ME.md — Restore UI + Add Voice Reply Fix (Isolated)

Promise: No UI changes. This only adds voice/STT/TTS/permissions as separate modules and a tiny bootstrap call.

Files to add (new only)

client/
  debug/DebugBus_safe.ts
  lib/permissions_safe.ts
  voice/
    tts_safe.ts
    gate_safe.ts
    stt_safe.ts
    alwaysListen_safe.ts
  llm/orchestrator_safe.ts


⸻

client/debug/DebugBus_safe.ts

type Level = 'ok'|'info'|'warn'|'error';
type Event = { tag: string; level: Level; msg: string; data?: any; ts?: number };

const listeners = new Set<(e: Event) => void>();
const flags = new Map<string, boolean>();

export const DebugBusSafe = {
  on(fn:(e:Event)=>void){ listeners.add(fn); return ()=>listeners.delete(fn); },
  emit(e: Event){
    e.ts = e.ts || Date.now();
    for (const fn of listeners) { try{ fn(e); }catch{} }
    const line = `[${new Date(e.ts).toISOString()}][${e.level}] ${e.tag}: ${e.msg}`;
    (e.level==='error'?console.error:e.level==='warn'?console.warn:console.log)(line, e.data??"");
  },
  defineFlags(names: string[]){ names.forEach(n=>flags.set(n,false)); },
  flag(name: string, val: boolean){ flags.set(name,val); DebugBusSafe.emit({tag:'FLAG',level:'info',msg:`${name}=${val}`}); },
  snapshot(){ return Object.fromEntries(flags.entries()); }
};

client/lib/permissions_safe.ts

export type MicState = 'unknown'|'granted'|'denied'|'blocked'|'prompt';
let audioUnlocked = false;

export async function unlockAudioContext(ctx: AudioContext) {
  if (ctx.state === 'suspended') await ctx.resume();
  audioUnlocked = true;
}
export function isAudioUnlocked(){ return audioUnlocked; }

export async function checkMicPermission(): Promise<MicState> {
  try {
    // @ts-ignore
    if (navigator.permissions?.query) {
      // @ts-ignore
      const s = await navigator.permissions.query({ name: 'microphone' as PermissionName });
      if (s.state==='granted') return 'granted';
      if (s.state==='denied')   return 'denied';
      return 'prompt';
    }
  } catch {}
  try {
    const strm = await navigator.mediaDevices.getUserMedia({ audio:true });
    strm.getTracks().forEach(t=>t.stop());
    return 'granted';
  } catch(e:any){
    const n = e?.name||'';
    if (n==='NotAllowedError'||n==='SecurityError') return 'denied';
    if (n==='NotFoundError') return 'blocked';
    return 'prompt';
  }
}

export async function requestMicStream(): Promise<MediaStream> {
  return navigator.mediaDevices.getUserMedia({
    audio:{ echoCancellation:true, noiseSuppression:true, autoGainControl:true, channelCount:1, sampleRate:44100 }
  });
}

client/voice/tts_safe.ts

import { DebugBusSafe } from '../debug/DebugBus_safe';
let utter: SpeechSynthesisUtterance | null = null;
let speaking = false;

export async function speakSafe(text: string){
  if (!('speechSynthesis' in window)) { DebugBusSafe.emit({tag:'TTS',level:'warn',msg:'no WebSpeech'}); return; }
  try{
    if (speaking && utter){ window.speechSynthesis.cancel(); speaking=false; }
    utter = new SpeechSynthesisUtterance(text||'');
    utter.rate=1; utter.pitch=1; utter.volume=1;
    utter.onstart=()=>{ speaking=true; DebugBusSafe.flag('TTS',true); };
    utter.onend=()=>{ speaking=false; DebugBusSafe.flag('TTS',false); };
    utter.onerror=(e:any)=>{ speaking=false; DebugBusSafe.emit({tag:'TTS',level:'error',msg:e?.error||'tts_error'}); };
    window.speechSynthesis.speak(utter);
  }catch(e:any){ DebugBusSafe.emit({tag:'TTS',level:'error',msg:e?.message||'tts_failed'}); }
}
export function stopSpeakSafe(){ try{ window.speechSynthesis.cancel(); }catch{} speaking=false; DebugBusSafe.flag('TTS',false); }

client/voice/gate_safe.ts

import { DebugBusSafe } from '../debug/DebugBus_safe';
let enabled=false; let wake='lolo';
export const VoiceGateSafe = {
  enable(word:string){ enabled=true; wake=(word||'lolo').toLowerCase(); DebugBusSafe.flag('Gate',true); },
  disable(){ enabled=false; DebugBusSafe.flag('Gate',false); },
  check(txt:string){
    if(!enabled) return {pass:true, cmd:txt};
    const raw=(txt||'').toLowerCase(); const i=raw.indexOf(wake);
    if(i===-1) return {pass:false, cmd:''};
    const cmd=raw.slice(i+wake.length).replace(/^[\s,.:;-]+/,'');
    return {pass:!!cmd, cmd};
  }
};

client/llm/orchestrator_safe.ts

export async function sendToLLMSafe(q:string){
  const t=q.toLowerCase().trim();
  if(/\btime\b/.test(t)){ const n=new Date(); return `The current time is ${n.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}.`; }
  if(/\bdate\b/.test(t)){ const n=new Date(); return `Today is ${n.toLocaleDateString()}.`; }
  if(/who\s*are\s*you/.test(t)||/your name/.test(t)) return "I'm Chango, online and listening.";
  return "Got it. What else should I do?";
}

client/voice/stt_safe.ts

import { DebugBusSafe } from '../debug/DebugBus_safe';
import { VoiceGateSafe } from './gate_safe';
import { speakSafe } from './tts_safe';
import { sendToLLMSafe } from '../llm/orchestrator_safe';

let rec: SpeechRecognition | null = null;

export async function startSTTSafe(){
  stopSTTSafe();
  const SR = (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;
  if(!SR) throw new Error('no_speech_recognition');

  rec = new SR(); rec.lang='en-US'; rec.continuous=true; rec.interimResults=true;

  rec.onresult = async (ev: SpeechRecognitionEvent) => {
    let final=''; for(let i=ev.resultIndex;i<ev.results.length;i++){ const r=ev.results[i]; if(r.isFinal) final+=r[0].transcript; }
    if(!final) return;
    const raw=final.trim(); DebugBusSafe.emit({tag:'STT',level:'info',msg:`heard="${raw.toLowerCase()}"`});
    const check=VoiceGateSafe.check(raw); if(!check.pass){ DebugBusSafe.emit({tag:'Gate',level:'info',msg:'ignored (no wake word)'}); return; }
    const reply = await sendToLLMSafe(check.cmd); DebugBusSafe.emit({tag:'Orch',level:'ok',msg:`reply="${(reply||'').slice(0,80)}..."`});
    await speakSafe(reply);
  };
  rec.onerror=(e:any)=>DebugBusSafe.emit({tag:'STT',level:'error',msg:e?.error||'stt_error'});
  rec.onend = ()=>{ DebugBusSafe.emit({tag:'STT',level:'warn',msg:'recognizer ended – auto-restart'}); try{ rec?.start(); }catch{} };

  try{ rec.start(); DebugBusSafe.emit({tag:'STT',level:'ok',msg:'recognizer started'}); }
  catch(e:any){ DebugBusSafe.emit({tag:'STT',level:'error',msg:`start failed: ${e?.message||e}`}); throw e; }
}

export function stopSTTSafe(){ try{ rec?.stop(); }catch{} rec=null; }

client/voice/alwaysListen_safe.ts

import { checkMicPermission, requestMicStream, unlockAudioContext } from '../lib/permissions_safe';
import { DebugBusSafe } from '../debug/DebugBus_safe';
import { startSTTSafe, stopSTTSafe } from './stt_safe';
import { VoiceGateSafe } from './gate_safe';

let running=false; let ctx: AudioContext | null = null;
async function ensureAudioUnlocked(){ if(!ctx) ctx=new (window.AudioContext||(window as any).webkitAudioContext)(); await unlockAudioContext(ctx); }

export async function startAlwaysListenSafe({ wakeWord='lolo', enabled=true }={}) {
  if(running||!enabled) return;
  try{
    await ensureAudioUnlocked();
    const state = await checkMicPermission();
    DebugBusSafe.emit({tag:'AlwaysListen',level:'info',msg:`perm=${state}`});
    if(state==='denied'||state==='blocked') throw new Error('mic_denied');

    const s = await requestMicStream(); s.getTracks().forEach(t=>t.stop());
    VoiceGateSafe.enable(wakeWord);
    await startSTTSafe();
    running=true; DebugBusSafe.flag('STT',true); DebugBusSafe.flag('Gate',true);
  }catch(e:any){
    running=false; DebugBusSafe.flag('STT',false); DebugBusSafe.flag('Gate',false);
    DebugBusSafe.emit({tag:'AlwaysListen',level:'error',msg:`startup_failed: ${e?.message||e}`});
  }
}

export async function stopAlwaysListenSafe(){
  try{ VoiceGateSafe.disable(); await stopSTTSafe(); }
  finally { running=false; DebugBusSafe.flag('STT',false); DebugBusSafe.flag('Gate',false); }
}


⸻

Wire it (2 lines) — keep your UI intact

In your existing bootstrap (where you already run app init, e.g., your current App.tsx effect or a global init file), add:

import { DebugBusSafe } from '@/debug/DebugBus_safe';
import { startAlwaysListenSafe } from '@/voice/alwaysListen_safe';

// inside your existing effect/init:
DebugBusSafe.defineFlags(['STT','TTS','Gate','Orch']);
startAlwaysListenSafe({ enabled: true, wakeWord: 'lolo' }); // change/disable gate if desired

That’s it. Your UI remains exactly as you built it; Chango starts listening and replies when addressed (with “lolo …” unless you disable the gate). Debug logs will tell you precisely where anything fails (permissions/STT/gate/TTS).