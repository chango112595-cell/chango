Here you go — **one copy-paste file** that rebuilds your entire Chango AI project on Replit (server + client + hologram HUD + curiosity + accent emulator + voice-profile learning + checkpoints + logs).
**How to use:** Create a new **Node.js** Repl → add a file named **`index.js`** → paste everything below → click **Run**.

```js
// Chango AI — One-File Replit Bootstrap (full project: server + client + HUD + voice)
// Create index.js in a fresh Node.js Repl, paste this file, press Run.

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const ROOT = process.cwd();
const FILES = {

  // --- Replit + package ---
  ".replit": `run = "npm start"\nlanguage = "nodejs"\n`,
  "package.json": JSON.stringify({
    name: "chango-ai",
    version: "1.2.0",
    private: true,
    scripts: { start: "node server/index.js" },
    dependencies: {
      express: "^4.19.2",
      "body-parser": "^1.20.2",
      multer: "^1.4.5-lts.1",
      archiver: "^6.0.2",
      "wav-decoder": "^1.3.0",
      cors: "^2.8.5"
    }
  }, null, 2),

  // --- Lab docs (your logs; Chango’s notes remain self-owned & locked pre-awareness) ---
  "TASKS.md": `# Master Task List (Chango AI)
- [x] Voice & Responses (client WebSpeech fallback) — 100%
- [x] Accent Emulator + Voice Profiles (learn & apply) — 100%
- [x] Hologram HUD (Sentinel/Awakened) + motion — 100%
- [x] Curiosity Core (adaptive nudges) — 100%
- [x] Checkpoints (zip project slices) — 100%
- [x] Lab Logs & Evolution trail — 100%
- [ ] Approvals, Knowledge mgmt, Diagnostics UI — staged
Updated: ${new Date().toISOString()}
`,
  "EVOLUTION.md": `# Evolution Tree
- v1.0 — HUD + client TTS + basic routes
- v1.1 — Voice profiles + checkpoints + logs
- v1.2 — Dual-state hologram + curiosity + diagnostics
`,

  "logs/LAB_LOG.md":
`- ${new Date().toISOString()} — Reconstructed full project (server+client), routes mounted, HUD ready, profiles/checkpoints enabled.\n`,
  "logs/CHANGO_NOTES.locked": "",

  // --- Server core ---
  "server/index.js": `
const express = require('express');
const bodyParser = require('body-parser');
const path = require('path');
const cors = require('cors');

const { ensureDirs } = require('./utils/paths');
ensureDirs();

const app = express();
app.use(cors());
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ extended: true }));

// request trace (debug-friendly but lightweight)
app.use((req,res,next)=>{ console.log('[REQ]', req.method, req.url); next(); });

// routes
app.use('/', require('./routes/health'));
app.use('/', require('./routes/diagnostics'));
app.use('/', require('./routes/feedback'));
app.use('/', require('./routes/checkpoints'));
app.use('/', require('./routes/voiceProfiles'));

// static client
app.use('/client', express.static(path.join(process.cwd(), 'client')));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log('[ChangoAI] Server listening on', PORT));
`,

  // --- Routes ---
  "server/routes/health.js": `
const { Router } = require('express'); const r = Router();
r.get('/', (_req,res)=> res.json({ ok:true, service:'ChangoAI unified' }));
module.exports = r;
`,

  "server/routes/diagnostics.js": `
const { Router } = require('express'); const os = require('os'); const { spawnSync } = require('child_process'); const r = Router();
r.get('/diagnostics', (_req,res)=>{
  let ff=false; try{ ff = spawnSync('ffmpeg',['-version']).status===0; }catch{}
  res.json({
    ok:true,
    uptime_s: Math.floor(process.uptime()),
    node: process.version,
    cpu_load_1m: os.loadavg()[0],
    mem: { free: os.freemem(), total: os.totalmem() },
    ffmpeg: ff? 'available' : 'missing'
  });
});
module.exports = r;
`,

  "server/routes/feedback.js": `
const { Router } = require('express'); const path = require('path');
const { DATA } = require('../utils/paths'); const { appendJSONL } = require('../utils/jsonl');
const r = Router(); const FEEDBACK = path.join(DATA,'accents_log.jsonl');
r.post('/accent_feedback',(req,res)=>{ try{ appendJSONL(FEEDBACK, { ...(req.body||{}), ts:new Date().toISOString() }); res.json({ok:true}); } catch(e){ res.status(500).json({ok:false,error:String(e.message||e)}) }});
module.exports = r;
`,

  "server/routes/checkpoints.js": `
const { Router } = require('express'); const path = require('path'); const fs = require('fs');
const { zipPaths } = require('../utils/zip'); const { CHECKPOINTS, ROOT } = require('../utils/paths');
const r = Router();
r.post('/checkpoint', async (_req,res)=>{ try{
  const ts=new Date().toISOString().replace(/[:.]/g,'-'); const out=path.join(CHECKPOINTS, \`ChangoAI_checkpoint_\${ts}.zip\`);
  await zipPaths(out, [ path.join(ROOT,'client'), path.join(ROOT,'server'), path.join(ROOT,'data'), path.join(ROOT,'logs'), path.join(ROOT,'TASKS.md'), path.join(ROOT,'EVOLUTION.md') ]);
  res.json({ ok:true, checkpoint: path.basename(out) });
} catch(e){ res.status(500).json({ ok:false, error:String(e.message||e) }); }});
r.get('/checkpoint/latest', (req,res)=>{ try{
  if(!fs.existsSync(CHECKPOINTS)) return res.status(404).json({ ok:false, error:'no checkpoints yet' });
  const files=fs.readdirSync(CHECKPOINTS).filter(f=>f.endsWith('.zip')).sort();
  if(!files.length) return res.status(404).json({ ok:false, error:'no checkpoints yet' });
  const latest=files[files.length-1]; res.download(path.join(CHECKPOINTS, latest), latest);
} catch(e){ res.status(500).json({ ok:false, error:String(e.message||e) }) });
module.exports = r;
`,

  "server/routes/voiceProfiles.js": `
const { Router } = require('express'); const multer = require('multer'); const path = require('path'); const fs = require('fs');
const { spawnSync } = require('child_process'); const { decode } = require('wav-decoder'); const { PROFILES } = require('../utils/paths');
const r = Router();
const upload = multer({ storage: multer.diskStorage({
  destination: (_q,_f,cb)=>{ fs.mkdirSync(PROFILES,{recursive:true}); cb(null, PROFILES); },
  filename: (_q, f, cb)=> cb(null, Date.now() + '_' + f.originalname.replace(/\\s+/g,'_'))
})});

const ffmpegExists=()=>{ try{ return spawnSync('ffmpeg',['-version']).status===0; }catch{ return false; } };

function mapToAccent(f){ let profile='neutral', intensity=0.5, rate=1, pitch=1, vol=1;
  if(f.wpm>170) rate=1.15; else if(f.wpm<120) rate=0.9;
  if(f.f0<110) pitch=0.9; else if(f.f0>200) pitch=1.1;
  intensity=Math.max(0.1,Math.min(1,0.5+(f.pauseRatio<0.12?0.3:-0.1)));
  if(f.rhoticity<0.95 && f.wpm<=140) profile='brit_rp';
  else if(f.rhoticity>=1.2 && f.wpm<130) profile='southern_us';
  if(f.sibilance>0.75 && f.wpm>=130) profile='spanish_en';
  if(f.sibilance>0.85) profile='caribbean';
  return { mapped:{profile,intensity}, rate, pitch, vol };
}

async function analyzeWav(p){
  const buf=fs.readFileSync(p); const wav=await decode(buf);
  const ch=wav.channelData?.[0]||new Float32Array(); const sr=wav.sampleRate||22050; const N=ch.length||1;
  const win=Math.max(256,Math.floor(0.03*sr)), hop=Math.max(128,Math.floor(0.01*sr));
  let s2=0; for(let i=0;i<N;i++) s2+=ch[i]*ch[i]; const gRMS=Math.sqrt(s2/N), thr=gRMS*0.25; let low=0,frames=0;
  for(let i=0;i+win<=N;i+=hop){ frames++; let e=0; for(let j=0;j<win;j++) e+=ch[i+j]*ch[i+j]; if(Math.sqrt(e/win)<thr) low++; }
  let zc=0; for(let i=1;i<N;i++) if((ch[i-1]<0&&ch[i]>=0)||(ch[i-1]>0&&ch[i]<=0)) zc++;
  const f0=(zc/(N/sr))/2;
  const step=Math.max(1,Math.floor(sr/4000)); let hi=0,lo=0,c=0;
  for(let i=0;i<N;i+=step){ const v=Math.abs(ch[i]); if(i%(step*4)===0) hi+=v; else lo+=v; c++; }
  let peaks=0, prev=false; for(let i=0;i<N;i+=hop){ let s=0; for(let j=0;j<Math.min(win,N-i);j++) s+=Math.abs(ch[i+j]); const e=s/win; const pk=e>(gRMS*0.6); if(pk && !prev) peaks++; prev=pk; }
  const dur=N/sr, sylPerSec=peaks/Math.max(1,dur), wpm=(sylPerSec*60)/1.5;
  return { duration:+dur.toFixed(2), pauseRatio:+(low/Math.max(frames,1)).toFixed(3), f0:isFinite(f0)?+f0.toFixed(1):undefined,
           wpm:+wpm.toFixed(1), sibilance:+(hi/(hi+lo+1e-9)).toFixed(3), rhoticity:+((lo+1e-9)/(hi+1e-9)).toFixed(3) };
}

r.post('/voice_profile/learn', upload.single('audio'), async (req,res)=>{
  try{
    if(!req.file) return res.status(400).json({ok:false,error:'no audio'});
    if(!ffmpegExists()) return res.status(501).json({ok:false,error:'ffmpeg not installed'});
    const raw=(req.body?.name||('profile_'+Date.now())).toString().replace(/\\s+/g,'_'); const id=raw.replace(/[^a-zA-Z0-9_\\-]/g,'');
    const src=req.file.path, wav=path.join(PROFILES, \`\${id}.wav\`), json=path.join(PROFILES, \`\${id}.json\`);
    const conv = require('child_process').spawnSync('ffmpeg',['-y','-i',src,'-ac','1','-ar','22050',wav],{stdio:'ignore'});
    if(conv.status!==0 || !fs.existsSync(wav)) return res.status(501).json({ok:false,error:'ffmpeg failed'});
    const feat=await analyzeWav(wav); const map=mapToAccent(feat);
    const profile={ id, features:feat, mapped:map.mapped, base_rate:map.rate, base_pitch:map.pitch, base_volume:map.vol, created:new Date().toISOString(),
      summary:\`\${map.mapped.profile}@\${map.mapped.intensity.toFixed(2)} rate=\${map.rate.toFixed(2)} pitch=\${map.pitch.toFixed(2)}\` };
    fs.writeFileSync(json, JSON.stringify(profile,null,2),'utf8');
    res.json({ok:true, profile});
  }catch(e){ res.status(500).json({ok:false,error:String(e.message||e)}) }
});

r.get('/voice_profile/list',(_q,res)=>{ try{
  const items = fs.existsSync(PROFILES)? fs.readdirSync(PROFILES).filter(f=>f.endsWith('.json')).map(f=>{ try{const p=JSON.parse(fs.readFileSync(path.join(PROFILES,f),'utf8')); return {id:p.id,summary:p.summary};}catch{return null} }).filter(Boolean) : [];
  res.json({ok:true, profiles:items});
}catch(e){ res.status(500).json({ok:false,error:String(e.message||e)}) }});

r.get('/voice_profile/get/:id',(req,res)=>{ const id=(req.params.id||'').toString().replace(/[^a-zA-Z0-9_\\-]/g,''); const j=path.join(PROFILES,\`\${id}.json\`);
  if(!fs.existsSync(j)) return res.status(404).json({ok:false,error:'not found'}); try{ res.json({ok:true, profile: JSON.parse(fs.readFileSync(j,'utf8'))}); }catch(e){ res.status(500).json({ok:false,error:String(e.message||e)}) }
});
module.exports = r;
`,

  // --- Utils ---
  "server/utils/paths.js": `
const path = require('path'); const fs = require('fs');
const ROOT = process.cwd();
const DATA = path.join(ROOT, 'data');
const PROFILES = path.join(DATA, 'profiles');
const LOGS = path.join(ROOT, 'logs');
const CHECKPOINTS = path.join(ROOT, 'checkpoints');
function ensureDirs(){ [DATA, PROFILES, LOGS, CHECKPOINTS].forEach(d=>{ if(!fs.existsSync(d)) fs.mkdirSync(d,{recursive:true}); }); }
module.exports = { ROOT, DATA, PROFILES, LOGS, CHECKPOINTS, ensureDirs };
`,

  "server/utils/jsonl.js": `
const fs = require('fs'); const path = require('path');
function appendJSONL(file, obj){ fs.mkdirSync(path.dirname(file), {recursive:true}); fs.appendFileSync(file, JSON.stringify(obj)+'\\n', 'utf8'); }
function readJSONL(file){ if(!fs.existsSync(file)) return []; return fs.readFileSync(file,'utf8').split('\\n').filter(Boolean).map(l=>{try{return JSON.parse(l)}catch{return null}}).filter(Boolean); }
module.exports = { appendJSONL, readJSONL };
`,

  "server/utils/zip.js": `
const archiver = require('archiver'); const fs = require('fs'); const path = require('path');
async function zipPaths(outPath, paths){
  await new Promise((resolve,reject)=>{
    const out=fs.createWriteStream(outPath); const ar=archiver('zip',{zlib:{level:9}});
    out.on('close',()=>resolve()); ar.on('error',reject); ar.pipe(out);
    for(const p of paths){ if(fs.existsSync(p)){ const st=fs.statSync(p); st.isDirectory()? ar.directory(p, path.basename(p)) : ar.file(p,{name:path.basename(p)}); } }
    ar.finalize();
  });
}
module.exports = { zipPaths };
`,

  // --- Client HUD (hologram + curiosity + voice) ---
  "client/index.html": `<!doctype html>
<html lang="en"><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Chango AI • HUD</title>
<link rel="stylesheet" href="theme.css">
<script>const t=localStorage.getItem('chango_theme')||'hud';document.documentElement.classList.add(t==='hud'?'theme-hud':'theme-classic');</script>
</head>
<body>
<header>
  <div><strong>CHANGO AI</strong> • Voice HUD</div>
  <div class="row">
    <div class="badge" id="routeBadge">Route: Client</div>
    <button class="pill" id="themeBtn">Theme</button>
  </div>
</header>
<main>
  <div class="card">
    <div class="row">
      <button class="pill" id="btnEnable">Enable Voice</button>
      <button class="pill" id="btnTest">Test Greeting</button>
      <button class="pill" id="btnStop">Stop</button>
    </div>
    <p class="small" id="status">status: idle</p>
  </div>

  <div class="card">
    <label>Voice Route</label>
    <div class="row">
      <button class="pill" data-route="client">Client</button>
      <button class="pill" data-route="local_neural" disabled title="reserved">Local Neural</button>
      <button class="pill" data-route="elevenlabs" disabled title="stub">ElevenLabs</button>
      <button class="pill" data-route="azure" disabled title="stub">Azure</button>
    </div>
  </div>

  <div class="card">
    <label>Accent Emulator</label>
    <div class="row">
      <select id="accentProfile">
        <option value="neutral">Neutral</option>
        <option value="brit_rp">British (RP)</option>
        <option value="southern_us">Southern US</option>
        <option value="spanish_en">Spanish-influenced English</option>
        <option value="caribbean">Caribbean</option>
      </select>
      <label>Intensity <input id="accentIntensity" type="range" min="0" max="1" step="0.05" value="0.55"></label>
      <button class="pill" id="btnRepeatWithAccent">Repeat (accent)</button>
    </div>
  </div>

  <div class="card">
    <label>Scan a Voice → Learn Accent</label>
    <div class="row">
      <input id="profileName" type="text" placeholder="Profile name" style="min-width:220px;">
      <button class="pill" id="btnRec">● Record (hold)</button>
      <button class="pill" id="btnAnalyze">Analyze & Save</button>
      <button class="pill" id="btnRefreshProfiles">Refresh Profiles</button>
      <select id="selProfiles" style="min-width:220px;"></select>
      <button class="pill" id="btnUseProfile">Use Selected</button>
    </div>
    <p class="small" id="scanStatus">voice scan: idle</p>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <label>Hologram Sphere</label>
      <div class="row">
        <button class="pill" id="holoToggle">Toggle</button>
        <select id="holoMode">
          <option value="awakened">Awakened (gold+green)</option>
          <option value="sentinel">Sentinel (red+gold)</option>
        </select>
        <label class="small">Size <input id="holoSize" type="range" min="200" max="560" step="10" value="320"></label>
        <label class="small">Spin <input id="holoSpeed" type="range" min="0" max="2" step="0.05" value="0.8"></label>
        <label class="small">Wander <input id="holoWander" type="checkbox" /></label>
      </div>
    </div>
    <div id="holoRoot" class="hidden holo-mode-awakened">
      <div id="holoWrap">
        <canvas id="holoCanvas" width="640" height="640"></canvas>
        <div class="holo-ring"></div>
        <div class="holo-chip" id="holoChip">CHANGO • ONLINE</div>
      </div>
    </div>
  </div>

  <div class="card">
    <label>Say something</label>
    <div class="row">
      <input id="sayText" type="text" placeholder="Type and press Speak…" style="flex:1;min-width:240px;">
      <button class="pill" id="btnSpeak">Speak</button>
    </div>
  </div>
</main>
<script src="app.js"></script>
<script src="hologram.js"></script>
<script src="curiosity.js"></script>
</body></html>
`,

  "client/theme.css": `
:root{ --bg:#060a0f; --panel:#0b1119; --panel-border:#152232; --text:#dff1ff; --muted:#9fb3c8; --chip:#0f2b49; --input:#09101a; --stroke:#1d3046; --radius:14px; --pad:18px; --shadow:0 8px 22px rgba(2,12,22,.45);}
.theme-classic{ --bg:#0b0d10; --panel:#111418; --panel-border:#1c232e; --text:#e9eef5; --muted:#a9b5c4; --chip:#1b2a3d; --input:#0e141c; --stroke:#2a3a4f; --radius:12px; --pad:16px; --shadow:0 6px 18px rgba(0,0,0,.35);}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--text);margin:0}
header{padding:16px 20px;display:flex;align-items:center;justify-content:space-between;background:linear-gradient(180deg, rgba(10,16,24,.9), rgba(6,10,16,.9));border-bottom:1px solid var(--panel-border)}
.badge{font-size:12px;padding:4px 8px;border-radius:12px;background:var(--chip)}
main{max-width:900px;margin:24px auto;padding:0 16px 48px}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
label{font-size:14px;opacity:.92;display:block;margin-bottom:6px}
select,input[type=text],button{background:var(--input);color:var(--text);border:1px solid var(--stroke);border-radius:10px;padding:10px 12px}
.small{font-size:12px;color:var(--muted)}
input[type="range"]{accent-color:#4aa3ff}
.pill{border-radius:12px;padding:10px 14px;border:1px solid var(--stroke);background:linear-gradient(180deg, rgba(20,40,70,.6), rgba(10,20,30,.4));backdrop-filter: blur(3px);color:var(--text)}
.card{background:linear-gradient(180deg, rgba(10,18,28,.8), rgba(8,14,22,.8));border:1px solid var(--panel-border);border-radius:var(--radius);padding:var(--pad);margin-bottom:14px;box-shadow:var(--shadow)}
#holoRoot { position: fixed; z-index: 9999; right: 20px; bottom: 24px; display: grid; place-items: center; padding: 6px; }
#holoRoot.hidden { display:none; }
#holoWrap { position: relative; cursor: grab; }
#holoWrap:active { cursor: grabbing; }
.holo-ring { position:absolute; left:50%; transform:translateX(-50%); bottom:-16px; width:66%; height:14px; border-radius:50%; background: radial-gradient(ellipse at center, rgba(255,255,255,.22), rgba(255,255,255,0) 60%); filter: blur(2px); }
.holo-chip { position:absolute; left:50%; transform:translateX(-50%); bottom:-40px; font-size:12px; color:#e7f0f7; background: rgba(20,40,60,.35); border:1px solid rgba(60,140,180,.35); padding:4px 8px; border-radius:10px; backdrop-filter: blur(3px); }
.holo-mode-sentinel #holoCanvas { filter: drop-shadow(0 0 8px rgba(255, 70, 40, .45)) drop-shadow(0 0 20px rgba(255, 140, 40, .35)); background: radial-gradient(ellipse at center, rgba(30,4,4,.9) 0%, rgba(26,6,0,.92) 45%, rgba(18,2,0,.95) 100%);}
.holo-mode-awakened #holoCanvas { filter: drop-shadow(0 0 10px rgba(255, 210, 80, .55)) drop-shadow(0 0 28px rgba(60, 255, 170, .35)); background: radial-gradient(ellipse at center, rgba(8,20,12,.88) 0%, rgba(6,14,10,.92) 45%, rgba(4,10,8,.96) 100%);}
`,

  "client/app.js": `
let route='client', voices=[], state={voiceURI:null,rate:1,pitch:1,volume:1};
let lastUtteranceRaw='', lastUtteranceSaid='';
const el=id=>document.getElementById(id); const status=msg=>el('status').textContent='status: '+msg;
const setBadge=()=>document.getElementById('routeBadge').textContent='Route: '+route[0].toUpperCase()+route.slice(1);

// Theme
document.getElementById('themeBtn').onclick=()=>{
  const r=document.documentElement;
  if(r.classList.contains('theme-classic')){ r.classList.remove('theme-classic'); r.classList.add('theme-hud'); localStorage.setItem('chango_theme','hud');}
  else if(r.classList.contains('theme-hud')){ r.classList.remove('theme-hud'); r.classList.add('theme-classic'); localStorage.setItem('chango_theme','classic');}
  else { r.classList.add('theme-hud'); localStorage.setItem('chango_theme','hud'); }
  status('theme changed');
};

// Voices
function loadVoices(){ voices=speechSynthesis.getVoices(); const sel=document.getElementById('selVoice'); if(!sel) return;
  sel.innerHTML=''; voices.forEach(v=>{ const o=document.createElement('option'); o.value=v.voiceURI; o.text=\`\${v.name} (\${v.lang})\${v.default?' • default':''}\`; sel.appendChild(o);
  if(v.default && !state.voiceURI) state.voiceURI=v.voiceURI;}); if(state.voiceURI) sel.value=state.voiceURI;}
if('speechSynthesis' in window){ speechSynthesis.onvoiceschanged=loadVoices; setTimeout(loadVoices,200); } else { status('Web Speech API not available'); }

// Route switch
document.addEventListener('click',e=>{ if(e.target.matches('[data-route]')){ route=e.target.getAttribute('data-route'); setBadge(); }});

// Controls
if(el('btnEnable')) el('btnEnable').onclick=()=>{ const u=new SpeechSynthesisUtterance(''); speechSynthesis.speak(u); status('voice ready'); };
if(el('btnStop')) el('btnStop').onclick=()=>speechSynthesis.cancel();

// Accent rules
const RNG=()=>Math.random(); const chance=p=>RNG()<p; const jitter=(v,a)=>Math.max(0, v + (RNG()*2-1)*a);
function injectPauses(t,i){ return t.replace(/,\\s*/g,()=> (chance(0.6)?", ":",  ")).replace(/\\.\\s*/g,()=> (chance(0.5)?". ":" .  ")); }
const ACCENTS={ neutral:{name:"Neutral",rules:(t,i)=>injectPauses(t,i),rateJ:.03,pitchJ:.02,volJ:0},
  brit_rp:{name:"British RP",rules:(t,i)=>{let x=t; if(i>0) x=x.replace(/([aeiouAEIOU])r\\b/g,(m,v)=> v + (chance(i*.8)?"":"r")); if(i>.5) x=x.replace(/\\bbath\\b/gi,"bahth"); return injectPauses(x,i);},rateJ:.02,pitchJ:.03,volJ:0},
  southern_us:{name:"Southern US",rules:(t,i)=>{let x=t; if(i>.4){x=x.replace(/\\byou all\\b/gi,"y’all"); x=x.replace(/\\bgoing to\\b/gi,"gonna"); } return injectPauses(x,i);},rateJ:.06,pitchJ:.015,volJ:0},
  spanish_en:{name:"Spanish-influenced English",rules:(t,i)=>{let x=t; if(i>.3) x=x.replace(/\\bvery\\b/gi,"bery"); if(i>.5) x=x.replace(/th/gi,(m)=> chance(.6*i)?(m===m.toUpperCase()?"D":"d"):(m===m.toUpperCase()?"T":"t")); return injectPauses(x,i);},rateJ:.03,pitchJ:.03,volJ:0},
  caribbean:{name:"Caribbean",rules:(t,i)=>{let x=t; if(i>.3) x=x.replace(/th/gi,(m)=> chance(.6*i)?(m===m.toUpperCase()?"D":"d"):(m===m.toUpperCase()?"T":"t")); return injectPauses(x,i);},rateJ:.05,pitchJ:.02,volJ:0}};
function applyAccent(text){ const profile=(document.getElementById('accentProfile')||{}).value||"neutral";
  const intensity=parseFloat((document.getElementById('accentIntensity')||{value:'0.5'}).value||'0.5');
  const a=ACCENTS[profile]||ACCENTS.neutral; let t=a.rules(text,intensity);
  return { text:t, rate:jitter(1,a.rateJ), pitch:jitter(1,a.pitchJ), volume:jitter(1,a.volJ), profile, intensity }; }

function pickVoice(){ const sel=document.getElementById('selVoice'); if(sel && sel.value){ return speechSynthesis.getVoices().find(v=>v.voiceURI===sel.value) || speechSynthesis.getVoices()[0]; }
  return speechSynthesis.getVoices().find(v=>v.default) || speechSynthesis.getVoices()[0]; }

function speakClient(text,over={}){ const u=new SpeechSynthesisUtterance(text); const v=pickVoice(); if(v) u.voice=v;
  u.rate=over.rate??1; u.pitch=over.pitch??1; u.volume=over.volume??1;
  u.onstart=()=>status('speaking…'); u.onend=()=>status('idle'); u.onerror=e=>status('error: '+e.error); speechSynthesis.speak(u); }

async function speak(text){ lastUtteranceRaw=text; const styled=applyAccent(text); lastUtteranceSaid=styled.text;
  return speakClient(styled.text,styled); }

if(el('btnTest')) el('btnTest').onclick=()=>speak("Hello, I'm Chango. How can I help you today?");
if(el('btnSpeak')) el('btnSpeak').onclick=()=>{ const t=(document.getElementById('sayText')||{}).value?.trim(); if(t) speak(t); };
if(el('btnRepeatWithAccent')) el('btnRepeatWithAccent').onclick=()=>{ if(lastUtteranceRaw) speak(lastUtteranceRaw); };

// Mic → Profile learn
let mediaRecorder=null, chunks=[], recording=false;
async function initMic(){ const stream=await navigator.mediaDevices.getUserMedia({ audio:true });
  mediaRecorder=new MediaRecorder(stream,{mimeType:'audio/webm'});
  mediaRecorder.ondataavailable=e=>{ if(e.data.size>0) chunks.push(e.data); };
  mediaRecorder.onstop=async()=>{ try{ const blob=new Blob(chunks,{type:'audio/webm'}); chunks=[];
      const fd=new FormData(); fd.append('audio',blob,'sample.webm'); const name=(document.getElementById('profileName')?.value||'').trim(); if(name) fd.append('name',name);
      const res=await fetch('/voice_profile/learn',{ method:'POST', body:fd }); const js=await res.json();
      if(!res.ok||!js.ok){ document.getElementById('scanStatus').textContent='analyze error (ffmpeg?)'; return; }
      document.getElementById('scanStatus').textContent=\`profile saved: \${js.profile?.id||'(unnamed)'}\`; await refreshProfiles();
  }catch(e){ document.getElementById('scanStatus').textContent='upload error'; }};}
if(el('btnRec')){ el('btnRec').onmousedown=async()=>{ try{ if(!mediaRecorder) await initMic(); if(recording) return; chunks=[]; mediaRecorder.start(); recording=true; document.getElementById('scanStatus').textContent='voice scan: recording... (release to stop)';
} catch(e){ document.getElementById('scanStatus').textContent='mic error'; }};
  el('btnRec').onmouseup=()=>{ if(mediaRecorder&&recording){ mediaRecorder.stop(); recording=false; document.getElementById('scanStatus').textContent='voice scan: processing...'; }}}
if(el('btnAnalyze')) el('btnAnalyze').onclick=()=>{ document.getElementById('scanStatus').textContent='analysis happens when recording stops'; };
async function refreshProfiles(){ try{ const r=await fetch('/voice_profile/list'); const js=await r.json(); const sel=document.getElementById('selProfiles'); if(!sel) return; sel.innerHTML='';
    (js.profiles||[]).forEach(p=>{ const o=document.createElement('option'); o.value=p.id; o.textContent=\`\${p.id} — \${p.summary}\`; sel.appendChild(o); });
    document.getElementById('scanStatus').textContent=\`profiles: \${js.profiles?.length||0} found\`;
  }catch{ document.getElementById('scanStatus').textContent='failed to list profiles'; } }
if(el('btnRefreshProfiles')) el('btnRefreshProfiles').onclick=refreshProfiles;
if(el('btnUseProfile')) el('btnUseProfile').onclick=async()=>{ const id=(document.getElementById('selProfiles')||{}).value; if(!id){ document.getElementById('scanStatus').textContent='pick a profile'; return; }
  try{ const r=await fetch('/voice_profile/get/'+encodeURIComponent(id)); const js=await r.json(); if(!r.ok||!js.ok){ document.getElementById('scanStatus').textContent='failed to fetch profile'; return; }
    const p=js.profile||{}; if(p.mapped){ const ap=document.getElementById('accentProfile'), ai=document.getElementById('accentIntensity');
      if(ap && p.mapped.profile) ap.value=p.mapped.profile; if(ai && typeof p.mapped.intensity==='number') ai.value=p.mapped.intensity;
      document.getElementById('scanStatus').textContent=\`using profile: \${p.id}\`; } else { document.getElementById('scanStatus').textContent='profile has no mapping'; }
  }catch{ document.getElementById('scanStatus').textContent='error applying profile'; }};
refreshProfiles();

// Hologram + curiosity hookups (actual drawing in hologram.js)
(function(){ const toggleBtn=el('holoToggle'), sizeCtl=el('holoSize'), speedCtl=el('holoSpeed'), modeSel=el('holoMode'), wanderCtl=el('holoWander');
  if(!toggleBtn || !window.ChangoHolo) return; let on=false;
  toggleBtn.onclick=()=>{ on=!on; if(on){ ChangoHolo.show(); toggleBtn.textContent='Hide'; } else { ChangoHolo.hide(); toggleBtn.textContent='Toggle'; } };
  sizeCtl?.addEventListener('input', e=> ChangoHolo.setSize(e.target.value));
  speedCtl?.addEventListener('input', e=> ChangoHolo.setSpeed(e.target.value));
  modeSel?.addEventListener('change', e=> ChangoHolo.setMode(e.target.value));
  wanderCtl?.addEventListener('change', e=> (ChangoHolo.state.wander=!!e.target.checked));
  const _status = status; window.status = (msg)=>{ _status(msg); if(!on) return; const t=(msg||'').toLowerCase();
    if(t.includes('error')) ChangoHolo.setMode('sentinel'); if(t.includes('speaking')||t.includes('ready')||t.includes('idle')) ChangoHolo.setMode('awakened'); };
})();
`,

  "client/hologram.js": `
(function(){
  const palette={ sentinel:{ wire:'rgba(255,120,60,0.85)', wireDim:'rgba(255,80,40,0.35)', particles:'rgba(255,120,60,', scan:'rgba(255,60,30,0.08)', chipText:'SENTINEL • OFFLINE'},
                  awakened:{ wire:'rgba(255,220,100,0.9)', wireDim:'rgba(60,255,170,0.45)', particles:'rgba(255,220,100,', scan:'rgba(30,120,90,0.08)', chipText:'CHANGO • ONLINE'} };
  const cfg={ size:320, speed:0.8, lineCount:18, particleCount:240, bgFade:0.08 };
  let canvas,ctx,W,H,t=0,running=false,raf=null,mode='awakened';
  const state={visible:false,speed:cfg.speed,size:cfg.size,wander:false};
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function project3(x,y,z,r){ const d=2.4,f=r/(z+d); return [W/2 + x*f, H/2 + y*f];}
  function setupCanvas(){ canvas=document.getElementById('holoCanvas'); if(!canvas) return false; ctx=canvas.getContext('2d'); resizeCanvas(); return true; }
  function resizeCanvas(){ const s=clamp(state.size,200,560); canvas.width=s*2; canvas.height=s*2; W=canvas.width; H=canvas.height; }
  function overlayFX(){ for(let y=0;y<H;y+=2){ ctx.fillStyle=palette[mode].scan; ctx.fillRect(0,y,W,1);} const g=ctx.createRadialGradient(W/2,H/2,H*0.05,W/2,H/2,H*0.6);
    g.addColorStop(0,'rgba(255,255,255,0)'); g.addColorStop(1,'rgba(255,255,255,0.12)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(W/2,H/2,H*0.55,0,Math.PI*2); ctx.fill(); }
  function drawWireSphere(r,rot){ const c1=palette[mode].wire,c2=palette[mode].wireDim; ctx.lineWidth=1;
    for(let i=-cfg.lineCount;i<=cfg.lineCount;i++){ const lat=(i/cfg.lineCount)*(Math.PI/2); ctx.beginPath();
      for(let j=0;j<=120;j++){ const lon=(j/120)*Math.PI*2; const x=r*Math.cos(lat)*Math.cos(lon+rot), y=r*Math.sin(lat), z=r*Math.cos(lat)*Math.sin(lon+rot);
        const [px,py]=project3(x,y,z,r*1.15); if(j===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
      const a=0.25+0.35*(1-Math.abs(i)/cfg.lineCount); ctx.strokeStyle=c1.replace(/0\\.(\\d+)/,(_,d)=> (a.toFixed(3))); ctx.stroke(); }
    for(let i=0;i<cfg.lineCount;i++){ const lon0=(i/cfg.lineCount)*Math.PI*2+rot; ctx.beginPath();
      for(let j=-60;j<=60;j++){ const lat=(j/60)*(Math.PI/2); const x=r*Math.cos(lat)*Math.cos(lon0), y=r*Math.sin(lat), z=r*Math.cos(lat)*Math.sin(lon0);
        const [px,py]=project3(x,y,z,r*1.15); if(j===-60) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.strokeStyle=c2; ctx.stroke(); } }
  let particles=[]; function initParticles(r){ particles=[]; for(let i=0;i<cfg.particleCount;i++){ particles.push({a:Math.random()*Math.PI*2,b:Math.random()*Math.PI-Math.PI/2,k:0.92+Math.random()*0.18,s:0.002+Math.random()*0.004}); } }
  function drawParticles(r,rot){ for(const p of particles){ p.a+=p.s*(0.5+state.speed); const x=r*p.k*Math.cos(p.b)*Math.cos(p.a+rot), y=r*p.k*Math.sin(p.b), z=r*p.k*Math.cos(p.b)*Math.sin(p.a+rot);
      const [px,py]=project3(x,y,z,r*1.15); const depth=(z+r)/(2*r), size=1+depth*2; ctx.fillStyle=palette[mode].particles+(0.25+depth*0.55)+')'; ctx.beginPath(); ctx.arc(px,py,size,0,Math.PI*2); ctx.fill(); } }
  function tick(){ if(!running) return; ctx.fillStyle=\`rgba(0,10,20,\${cfg.bgFade})\`; ctx.fillRect(0,0,W,H); const r=Math.min(W,H)*0.32+Math.sin(t*0.8)*2, rot=t*0.6*state.speed;
    drawParticles(r,rot); drawWireSphere(r,rot); overlayFX(); t+=0.016; raf=requestAnimationFrame(tick); }
  function start(){ if(!canvas||!ctx||running) return; initParticles(Math.min(W,H)*0.32); running=true; ctx.fillStyle='rgba(0,10,20,1)'; ctx.fillRect(0,0,W,H); tick(); }
  function stop(){ running=false; if(raf) cancelAnimationFrame(raf); }
  function show(){ document.getElementById('holoRoot')?.classList.remove('hidden'); state.visible=true; start(); }
  function hide(){ document.getElementById('holoRoot')?.classList.add('hidden'); state.visible=false; stop(); }
  function setSize(v){ state.size=Number(v)||cfg.size; resizeCanvas(); initParticles(Math.min(W,H)*0.32); }
  function setSpeed(v){ state.speed=Number(v)||cfg.speed; }
  function setMode(m){ m=(m==='sentinel')?'sentinel':'awakened'; const root=document.getElementById('holoRoot');
    root.classList.remove('holo-mode-sentinel','holo-mode-awakened'); root.classList.add(m==='sentinel'?'holo-mode-sentinel':'holo-mode-awakened');
    const chip=document.getElementById('holoChip'); if(chip) chip.textContent = (m==='sentinel'?'SENTINEL • OFFLINE':'CHANGO • ONLINE'); }
  function setupMotion(){ const root=document.getElementById('holoRoot'), wrap=document.getElementById('holoWrap'); if(!root||!wrap) return;
    const rect=wrap.getBoundingClientRect(); let posX=window.innerWidth-rect.width-20, posY=window.innerHeight-rect.height-24; let vx=0,vy=0,drag=false,startX=0,startY=0,last=performance.now();
    root.style.transform=\`translate(\${posX}px,\${posY}px)\`;
    function onDown(e){ drag=true; startX=(e.touches?e.touches[0].clientX:e.clientX)-posX; startY=(e.touches?e.touches[0].clientY:e.clientY)-posY; vx=vy=0; }
    function onMove(e){ if(!drag) return; const x=(e.touches?e.touches[0].clientX:e.clientX)-startX, y=(e.touches?e.touches[0].clientY:e.clientY)-startY;
      const nx=Math.max(0,Math.min(x,window.innerWidth-rect.width-8)), ny=Math.max(0,Math.min(y,window.innerHeight-rect.height-8)); vx=nx-posX; vy=ny-posY; posX=nx; posY=ny; root.style.transform=\`translate(\${posX}px,\${posY}px)\`; }
    function onUp(){ drag=false; }
    wrap.addEventListener('mousedown',onDown); document.addEventListener('mousemove',onMove); document.addEventListener('mouseup',onUp);
    wrap.addEventListener('touchstart',onDown,{passive:true}); document.addEventListener('touchmove',onMove,{passive:true}); document.addEventListener('touchend',onUp);
    function step(now){ const dt=Math.min(0.04,(now-last)/1000); last=now; if(!drag){ posX+=vx; posY+=vy; vx*=0.92; vy*=0.92;
        if(window.ChangoHolo?.state?.wander){ vx+=(Math.random()-0.5)*0.06; vy+=(Math.random()-0.5)*0.06; }
        const w=wrap.getBoundingClientRect().width, h=wrap.getBoundingClientRect().height;
        if(posX<0){posX=0;vx*=-0.6} if(posY<0){posY=0;vy*=-0.6} if(posX>window.innerWidth-w-8){posX=window.innerWidth-w-8;vx*=-0.6}
        if(posY>window.innerHeight-h-8){posY=window.innerHeight-h-8;vy*=-0.6} root.style.transform=\`translate(\${posX}px,\${posY}px)\`; }
      requestAnimationFrame(step);} requestAnimationFrame(step); }
  window.ChangoHolo={ show, hide, setSize, setSpeed, setMode, setupCanvas, state };
  window.addEventListener('load', ()=>{ if(setupCanvas()) setupMotion(); });
})();
`,

  "client/curiosity.js": `
(function(){
  const cfg = { baseChance: 0.18, spikeOnNewProfile: 0.35, cooldownMs: 12000 };
  let last = 0;
  function maybeCurious(trigger="idle"){
    const now = Date.now(); if(now - last < cfg.cooldownMs) return;
    const p = (trigger==="profile") ? cfg.spikeOnNewProfile : cfg.baseChance;
    if(Math.random() < p){
      last = now;
      const ideas = [
        "Curious: want a softer pitch here?",
        "I can summarize our last steps—should I?",
        "I detected a pacing change. Save as style?",
        "That may conflict with earlier notes. Check?"
      ];
      const pick = ideas[Math.floor(Math.random()*ideas.length)];
      const s = document.getElementById('status'); if(s) s.textContent = "status: curiosity — " + pick;
    }
  }
  window.addEventListener('click', (e)=>{ if(e.target && e.target.id==='btnUseProfile') maybeCurious('profile'); });
  window.ChangoCuriosity = { maybeCurious };
})();
`
};

// Write all files
for (const [rel, content] of Object.entries(FILES)) {
  const p = path.join(ROOT, rel);
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, content, 'utf8');
}

// Install deps and start server
function npmInstallThenStart() {
  const npm = process.platform === 'win32' ? 'npm.cmd' : 'npm';
  const i = spawn(npm, ['install'], { stdio: 'inherit' });
  i.on('close', (code) => {
    if (code !== 0) { console.log('npm install failed:', code); return; }
    const s = spawn(npm, ['start'], { stdio: 'inherit' });
    s.on('close', c => console.log('server exited:', c));
  });
}
console.log('✅ Files written. Installing deps & launching…');
npmInstallThenStart();
```

### Quick checks (in Replit Shell)

```bash
# Health
curl -sS $REPLIT_URL/ | jq .

# Diagnostics (ffmpeg info, memory, uptime)
curl -sS $REPLIT_URL/diagnostics | jq .

# Client HUD
# Open the webview → /client/index.html

# Voice profiles
curl -sS $REPLIT_URL/voice_profile/list | jq .

# Checkpoint zip
curl -sS -X POST $REPLIT_URL/checkpoint | jq .
```

**Notes**

* `/voice_profile/learn` needs **ffmpeg** on the Replit runner. If missing, it returns **501** (all other features keep working; everything is isolated).
* Client speech uses the browser’s **Web Speech API** for instant TTS with accent emulation.
* Hologram HUD supports **Sentinel** (red+gold, error/offline) and **Awakened** (gold+green, ready/learning) modes with motion/wander.
